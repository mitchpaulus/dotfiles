# variables:
# $f = Current file selection as full path
# $fs = Selected file(s) separated with the value of 'filesep' option as full path(s)

# Prefixes:
# :  read (default)  builtin/custom command
# $  shell           shell command
# %  shell-pipe      shell command running with the ui (standard output of command is printed to statusline)
# !  shell-wait      shell command waiting for key press
# &  shell-async     shell command running asynchronously

# Default open: cmd open &$OPENER $f
set hidden true
# set mouse on
set previewer lf-preview
map <esc> quit

map t push !tmsu<space>tag<space>"$f"<space>
# 'showtags' is script in dotfiles
map T %showtags "$f"

map ga &git add "$f"
map gr &git rm --cached "$f"

# Unmap single y
map y

map <f-5> reload
map <c-v> page-down
map <a-v> page-up

map yy copy
map yf copy-filename
map yg copy-gitpath
map yp copy-fullpath
map yw copy-windows-full-path
map yc copy-command-path
# Short for 'yank data'
map yd copy-contents
# Short for 'yank text'
map yt copy-contents

# Remap 'f' key. Never really use the find functionality.
map f mark-load
map ; mark-load

cmd binlink % binlink "$f" && printf "Successfully linked %s\n" "$f"
map bl binlink

cmd copy-filename & basename "$f" | tr -d '\n' | clip
cmd copy-fullpath & printf '%s' "$f" | clip
cmd copy-contents &clip < "$f"
cmd copy-windows-full-path &{{
    if command -v wslpath >/dev/null 2>/dev/null; then
        wslpath -w "$f" | tr -d '\n' | clip
    else
        printf '%s' "$f" | wslpathmp | tr -d '\n' | clip
    fi
}}
cmd copy-command-path & CCLLCCopyToClip.exe "$(wslpath -w "$f")"

cmd copy-gitpath & gitpath "$f" | clip

# Changing to syncronous mode instead of the default asyncronous mode because I want to use the terminal editor for most things.
cmd open $ "$OPENER" "$f"
# map e $env VIMRUNTIME="$REPOS"/neovim/runtime "$REPOS"/neovim/build/bin/nvim "$f"

cmd on-cd $ if test -n "$WSL_DISTRO_NAME"; then printf "\e]9;9;%s\e\\" "$(wslpath -w "$PWD")"; fi

map <f-2> rename

cmd mkdir &mkdir "$1"; lf -remote "send $id reload"
